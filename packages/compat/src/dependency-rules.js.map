{"version":3,"file":"dependency-rules.js","sourceRoot":"","sources":["dependency-rules.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Resolver } from '@embroider/core';\nimport { getOrCreate } from '@embroider/core';\nimport { resolve } from 'path';\nimport { satisfies } from 'semver';\n\nexport interface PackageRules {\n  // This whole set of rules will only apply when the given addon package\n  // matching the given semver range is present and active.\n  package: string;\n  semverRange?: string;\n\n  components?: {\n    // I would prefer to write the key type here as `ComponentSnippet` to aid\n    // documentation, but Typescript won't allow it. See ComponentSnippet below.\n    [key: string]: ComponentRules;\n  };\n\n  addonModules?: {\n    // `filename` is relative to your package root, and it assumes v2 package\n    // format. Like \"templates/components/foo.hbs\".\n    [filename: string]: ModuleRules;\n  };\n\n  appModules?: {\n    // `filename` is relative to the app's root, and it assumes v2 package\n    // format. Like \"templates/components/foo.hbs\".\n    [filename: string]: ModuleRules;\n  };\n\n  addonTemplates?: {\n    // `filename` is relative to your package root, and it assumes v2 package\n    // format. Like \"templates/foo.hbs\".\n    [filename: string]: TemplateRules;\n  };\n\n  appTemplates?: {\n    // `filename` is relative to the app's root, and it assumes v2 package\n    // format. Like \"templates/foo.hbs\".\n    [filename: string]: TemplateRules;\n  };\n}\n\nexport interface ActivePackageRules extends PackageRules {\n  // the location(s) of active packages that match this rule.\n  roots: string[];\n}\n\nexport interface TemplateRules {\n  // Tells embroider which list of components may be needed for a given path.\n  // For example, if your template says `{{component this.panel}}` and you know\n  // that `this.panel` can be either \"light-panel\" or \"dark-panel\", you would\n  // say: `invokes: { \"this.panel\": [\"<LightPanel/>\", \"<DarkPanel/>\"] }`\n  invokes?: {\n    [path: string]: ComponentSnippet[];\n  };\n\n  // Embroider will complain if you try to use staticHelper and/or\n  // staticComponents and you have ambiguous forms that might be a component or\n  // a helper or just some data that is being rendered. For example, if a\n  // template says `{{something}}`, we can't tell if that is `<Something />` or\n  // `{{ (something) }}` or `{{this.something}}`.\n  disambiguate?: {\n    [dasherizedName: string]: 'component' | 'helper' | 'data';\n  };\n}\n\nexport interface ComponentRules extends TemplateRules {\n  // This declares that our component yields other components that are safe to\n  // invoke with the {{component}} helper.\n  //\n  // The array corresponds to your yielded positional arguments. Any value that\n  // is true is considered a safe component. Any value can be a hash in which\n  // individual keys that are true are considered safe components.\n  //\n  //  Examples:\n  //\n  //    If you do: {{yield (component \"x\") }}\n  //    Then say: yieldsSafeComponents: [true]\n  //\n  //    If you do: {{yield (hash x=(component \"x\") y=(component \"y\")) }}\n  //    Then say: yieldsSafeComponents: [{x: true, y: true}]\n  //\n  yieldsSafeComponents?: (boolean | { [name: string]: boolean })[];\n\n  // This declares that our component yields some of its arguments unchanged.\n  //\n  // The array corresponds to your yielded positional arguments. Each value can\n  // be:\n  //   false, meaning this yielded value is not one of our arguments\n  //   a string, meaning this yielded value is our argument with that name\n  //   or a POJO, whose individual properties are string naming which arguments\n  //     from whence they came.\n  //\n  // Examples:\n  //\n  //    If you do: {{yield @foo}}\n  //    Then say: yieldsArguments: ['foo']\n  //\n  //    If you do: {{yield (hash x=@foo) }}\n  //    Then say: yieldsArguments: [{ x: 'foo' }]\n  yieldsArguments?: (string | { [name: string]: string })[];\n\n  // This declares that our component accepts arguments that will be invoked\n  // with the {{component}} helper. This silences warnings in the places where\n  // we consume them, while introducing warnings in the places where people are\n  // passing them to us (if they are doing so in a way that is too dynamic to\n  // analyze).\n  //\n  // If you use this, you may also need to set `layout`, see below.\n  acceptsComponentArguments?: ArgumentMapping[];\n\n  // If you want to use `acceptsComponentArguments` on a component that\n  // customies its own `layout` (which is most addon-provided components), you\n  // need to tell us here how to find its template by setting either `addonPath`\n  // or `appPath`.\n  layout?: {\n    // This is a path relative to the addon root, assuming V2 format.\n    addonPath?: string;\n    // This is the path relative to the app root, assuming V2 format.\n    appPath?: string;\n  };\n\n  // An unresolvable component is usually a build error (when your app has the\n  // staticComponent Option enabled). But you can tell Embroider to ignore it by\n  // setting this.\n  safeToIgnore?: boolean;\n}\n\nexport interface ModuleRules {\n  // We will resolve these components into the corresponding JS and HBS files\n  // and generate imports such that this module depends on them.\n  dependsOnComponents?: ComponentSnippet[];\n\n  // This adds new imports to our module, as if they were really there. Helpful\n  // for working around addons that depend on things but don't say so.\n  dependsOnModules?: string[];\n}\n\n// The bare \"string\" short form implies that `becomes` is the same as `name`.\nexport type ArgumentMapping =\n  | string\n  | {\n      // the name of the argument you accept\n      name: string;\n      // the name its consumed as in your template\n      becomes: string;\n    };\n\n// A component snippet is a string containing valid HBS that is a single\n// component invocation. We use it to refer to components in a way that doesn't\n// require any new syntax or rules, and that's necessarily supported by whatever\n// build-time template resolver is in use.\n//\n// Examples of valid ComponentSnippets:\n//\n//    \"{{my-component}}\"\n//    \"{{my-component/foo}}\"\n//    \"<MyComponent />\"\n//    \"{{component 'my-component'}}\"\n//\ntype ComponentSnippet = string;\n\nexport interface PreprocessedComponentRule {\n  yieldsSafeComponents: Required<ComponentRules>['yieldsSafeComponents'];\n  yieldsArguments: Required<ComponentRules>['yieldsArguments'];\n  argumentsAreComponents: string[];\n  safeToIgnore: boolean;\n  safeInteriorPaths: string[];\n  disambiguate: Record<string, 'component' | 'helper' | 'data'>;\n}\n\n// take a component rule from the authoring format to a format more optimized\n// for consumption in the resolver\nexport function preprocessComponentRule(componentRules: ComponentRules): PreprocessedComponentRule {\n  let argumentsAreComponents = [];\n  let safeInteriorPaths = [];\n  if (componentRules.acceptsComponentArguments) {\n    for (let entry of componentRules.acceptsComponentArguments) {\n      let name, interior;\n      if (typeof entry === 'string') {\n        name = interior = entry;\n      } else {\n        name = entry.name;\n        interior = entry.becomes;\n      }\n      if (name.startsWith('@')) {\n        name = name.slice(1);\n      }\n      argumentsAreComponents.push(name);\n      safeInteriorPaths.push(interior);\n      safeInteriorPaths.push('this.' + interior);\n      safeInteriorPaths.push('@' + name);\n    }\n  }\n  if (componentRules.invokes) {\n    for (let [path] of Object.entries(componentRules.invokes)) {\n      safeInteriorPaths.push(path);\n    }\n  }\n  return {\n    safeInteriorPaths,\n    safeToIgnore: Boolean(componentRules.safeToIgnore),\n    argumentsAreComponents,\n    yieldsSafeComponents: componentRules.yieldsSafeComponents || [],\n    yieldsArguments: componentRules.yieldsArguments || [],\n    disambiguate: componentRules?.disambiguate ?? {},\n  };\n}\n\nexport function activePackageRules(\n  packageRules: PackageRules[],\n  activePackages: { name: string; root: string; version: string }[]\n): ActivePackageRules[] {\n  // rule order implies precedence. The first rule that matches a given package\n  // applies to that package, and no other rule does.\n  let rootsPerRule = new Map();\n  for (let pkg of activePackages) {\n    for (let rule of packageRules) {\n      if (rule.package === pkg.name && (!rule.semverRange || satisfies(pkg.version, rule.semverRange))) {\n        let roots = getOrCreate(rootsPerRule, rule, () => []);\n        roots.push(pkg.root);\n        break;\n      }\n    }\n  }\n  let output = [];\n  for (let [rule, roots] of rootsPerRule) {\n    output.push(Object.assign({ roots }, rule));\n  }\n  return output;\n}\n\nexport function appTreeRulesDir(root: string, resolver: Resolver) {\n  let pkg = resolver.packageCache.ownerOfFile(root);\n  if (pkg?.isV2Addon()) {\n    // in general v2 addons can keep their app tree stuff in other places than\n    // \"_app_\" and we would need to check their package.json to see. But this code\n    // is only for applying packageRules to auto-upgraded v1 addons and apps, and\n    // those we always organize predictably.\n    return resolve(root, '_app_');\n  } else {\n    // auto-upgraded apps don't get an exist _app_ dir.\n    return root;\n  }\n}\n"]}