{"version":3,"file":"options.js","sourceRoot":"","sources":["options.ts"],"names":[],"mappings":";;;AA8GA,kDAEC;AA7GD,0CAA0E;AAgG1E,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,IAAA,0BAAgB,GAAE,EAAE;IACjD,gBAAgB,EAAE,KAAK;IACvB,2BAA2B,EAAE,KAAK;IAClC,iBAAiB,EAAE,KAAK;IACxB,cAAc,EAAE,IAAI,GAAG,EAAE;IACzB,gBAAgB,EAAE,EAAE;IACpB,YAAY,EAAE,IAAI;IAClB,YAAY,EAAE,EAAE;IAChB,4BAA4B,EAAE,KAAK;CACpC,CAAC,CAAC;AAEH,SAAgB,mBAAmB,CAAC,OAAiB;IACnD,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC9C,CAAC;AAED,+EAA+E;AAC/E,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACD,QAAA,kBAAkB,GAAgC,MAAM,CAAC,MAAM,CAAC;IAC3E,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;IACvB,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC;QACvB,gBAAgB,EAAE,IAAI;QACtB,2BAA2B,EAAE,IAAI;QACjC,aAAa,EAAE,IAAI;QACnB,eAAe,EAAE,IAAI;QACrB,gBAAgB,EAAE,IAAI;QACtB,iBAAiB,EAAE,IAAI;QACvB,4BAA4B,EAAE,KAAK;KACpC,CAAC;CACH,CAAC,CAAC","sourcesContent":["import type { V1AddonConstructor } from './v1-addon';\nimport type { Node } from 'broccoli-node-api';\nimport type { Options as CoreOptions } from '@embroider/core';\nimport { optionsWithDefaults as coreWithDefaults } from '@embroider/core';\nimport type { PackageRules } from './dependency-rules';\n\n// These options control how hard we will try to achieve compatibility with v1\n// addons. The defaults are conservative and try to maximize compatibility, at\n// the cost of slower or bigger builds. As you eliminate sources of legacy\n// behavior you can benefit from the more aggressive modes.\nexport default interface Options extends CoreOptions {\n  // Controls whether your addon's \"addon\" trees should be resolved statically\n  // at build time.\n  //\n  //   false (the default): implies maximum backward compatibility at the cost\n  //   of bigger builds. In this mode, we force every file into the Ember app,\n  //   which is the legacy behavior.\n  //\n  //   true: produces smaller builds. The addon files must be imported from\n  //   somewhere we can statically see during the build. In this mode, your app\n  //   will only include files that are actually imported from somewhere.\n  //\n  // Commentary: most v1 addons already work well with this set to true, because\n  // they tend to either offer Javascript that users are supposed to directly\n  // `import` or components / helpers / services that get directly imported and\n  // re-exported by code in App Javascript. The exceptions are addons that do\n  // runtime shenanigans with `require` or scoped runtime resolutions.\n  //\n  // To workaround an addon that is preventing you from enabling this flag, you\n  // can use addonDependencyRules.\n  staticAddonTrees?: boolean;\n\n  // Controls whether your addon's \"addonTestSupport\" trees should be resolved\n  // statically at build time.\n  //\n  //   false (the default): implies maximum backward compatibility at the cost\n  //   of bigger builds. All test support files will be forced into your Ember\n  //   app, which is the legacy behavior.\n  //\n  //   true: produces smaller builds. Only files that are explicitly imported\n  //   will end up in your app.\n  //\n  // Commentary: this is analogous to staticAddonTrees and the same guidelines\n  // apply.\n  staticAddonTestSupportTrees?: boolean;\n\n  // when true, we will load ember-source as ES modules. This means unused parts\n  // of ember-source won't be included. But it also means that addons using old\n  // APIs to try to `require()` things from Ember -- particularly from within\n  // vendor.js -- cannot do that anymore.\n  //\n  // When false (the default) we load ember-source the traditional way, which is\n  // that a big ol' script gets smooshed into vendor.js, and none of ember's\n  // public module API actually exists as modules at build time.\n  staticEmberSource?: boolean;\n\n  // Allows you to override how specific addons will build. Like:\n  //\n  //   import V1Addon from '@embroider/compat'; let compatAdapters = new Map();\n  //   compatAdapters.set('some-addon', class extends V1Addon {// do stuff here:\n  //   see examples in ./compat-adapters\n  //   });\n  //\n  // This should be understood as a temporary way to keep yourself from getting\n  // stuck, not an alternative to actually fixing upstream. For the most part,\n  // the real solution will be converting the addon in question to natively\n  // publish as v2.\n  //\n  // We ship with some default compatAdapters to fix otherwise incompatible\n  // behaviors in popular addons. You can override the default adapters by\n  // setting your own value here (including null to completely disable it).\n  compatAdapters?: Map<string, V1AddonConstructor | null>;\n\n  // optional list of additional broccoli trees that should be incorporated into\n  // the final build. This exists because the classic `app.toTree()` method\n  // accepts an optional tree argument that has the same purpose.\n  extraPublicTrees?: Node[];\n\n  // Allows you to tell Embroider about otherwise dynamic dependencies within\n  // your app and addons that it can't figure out on its own. These are combined\n  // with the default rules that ship with Embroider. Your own rules take\n  // precedence over the built-ins. Order matters, first matching rule will\n  // apply to any given addon.\n  //\n  // See the addon-dependency-rules directory in the @embroider/compat package\n  // for the built-in rules.\n  //\n  // These ONLY APPLY to v1-formatted addons. An addon that ships as native v2\n  // is expected to do the right thing on its own.\n  //\n  // Follow to the definition of PackageRules for more info.\n  packageRules?: PackageRules[];\n\n  // This turns build errors into runtime errors. It is not a good idea to keep\n  // it on in production. But it can be helpful when testing how much of your\n  // app is able to work with staticComponents enabled.\n  allowUnsafeDynamicComponents?: boolean;\n}\n\nconst defaults = Object.assign(coreWithDefaults(), {\n  staticAddonTrees: false,\n  staticAddonTestSupportTrees: false,\n  staticEmberSource: false,\n  compatAdapters: new Map(),\n  extraPublicTrees: [],\n  workspaceDir: null,\n  packageRules: [],\n  allowUnsafeDynamicComponents: false,\n});\n\nexport function optionsWithDefaults(options?: Options): Required<Options> {\n  return Object.assign({}, defaults, options);\n}\n\n// These are recommended configurations for addons to test themselves under. By\n// keeping them here, it's easier to do ecosystem-wide compatibility testing.\n// See the `@embroider/test-setup` package which can help consume these to test\n// them in CI.\nexport const recommendedOptions: { [name: string]: Options } = Object.freeze({\n  safe: Object.freeze({}),\n  optimized: Object.freeze({\n    staticAddonTrees: true,\n    staticAddonTestSupportTrees: true,\n    staticHelpers: true,\n    staticModifiers: true,\n    staticComponents: true,\n    staticEmberSource: true,\n    allowUnsafeDynamicComponents: false,\n  }),\n});\n"]}