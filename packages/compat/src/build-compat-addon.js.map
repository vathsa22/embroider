{"version":3,"file":"build-compat-addon.js","sourceRoot":"","sources":["build-compat-addon.ts"],"names":[],"mappings":";;;;;AAOA,mCAoCC;AAzCD,gFAAsD;AACtD,gFAAsD;AAEtD,8EAAoD;AAEpD,SAAwB,gBAAgB,CAAC,eAAwB,EAAE,OAAwB;IACzF,IAAI,eAAe,CAAC,SAAS,EAAE,EAAE,CAAC;QAChC,MAAM,IAAI,KAAK,CACb,uEAAuE,eAAe,CAAC,IAAI,OAAO,eAAe,CAAC,IAAI,gBAAgB,CACvI,CAAC;IACJ,CAAC;IAED,IAAI,WAAW,GAAG,OAAO,CAAC,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IAE1D,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC3B,sEAAsE;QACtE,2EAA2E;QAC3E,+BAA+B;QAC/B,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;IAC5D,CAAC;IAED,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC7B,yEAAyE;QACzE,4EAA4E;QAC5E,kCAAkC;QAClC,EAAE;QACF,yEAAyE;QACzE,gEAAgE;QAChE,0EAA0E;QAC1E,2BAA2B;QAC3B,OAAO,IAAI,4BAAgB,CAAC,eAAe,CAAC,CAAC;IAC/C,CAAC;IAED,IAAI,cAAc,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;IAC5E,IAAI,cAAc,EAAE,CAAC;QACnB,IAAI,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC;QACzD,IAAI,QAAQ,GAAG,IAAI,6BAAiB,CAAC,KAAK,EAAE,EAAE,UAAU,EAAE,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC;QAClF,OAAO,IAAA,8BAAkB,EAAC,CAAC,GAAG,KAAK,EAAE,QAAQ,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACvE,CAAC;SAAM,CAAC;QACN,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IAC/B,CAAC;AACH,CAAC","sourcesContent":["import type V1InstanceCache from './v1-instance-cache';\nimport type { Package } from '@embroider/core';\nimport SmooshPackageJSON from './smoosh-package-json';\nimport broccoliMergeTrees from 'broccoli-merge-trees';\nimport type { Node } from 'broccoli-node-api';\nimport EmptyPackageTree from './empty-package-tree';\n\nexport default function buildCompatAddon(originalPackage: Package, v1Cache: V1InstanceCache): Node {\n  if (originalPackage.isV2Addon()) {\n    throw new Error(\n      `bug in @embroider/compat. We should not see any v2 addons here, but ${originalPackage.name} as ${originalPackage.root} is a v2 addon`\n    );\n  }\n\n  let oldPackages = v1Cache.getAddons(originalPackage.root);\n\n  if (oldPackages.length > 1) {\n    // extensibility hook that allows a compat adapter to optimize its own\n    // smooshing. We do it early so that if it reduces all the way to zero, the\n    // next check will handle that.\n    oldPackages = oldPackages[0].reduceInstances(oldPackages);\n  }\n\n  if (oldPackages.length === 0) {\n    // this happens when the v1 addon wasn't actually getting instantiated at\n    // all, which can happen if the app uses `addons.blacklist` or another addon\n    // uses `shouldIncludeChildAddon`.\n    //\n    // we still keep a place for this addon in the rewritten addon workspace,\n    // because that whole process only depends on looking at all the\n    // package.json files on disk -- it can't know which ones are going to end\n    // up unused at this point.\n    return new EmptyPackageTree(originalPackage);\n  }\n\n  let needsSmooshing = oldPackages.length > 1 && oldPackages[0].hasAnyTrees();\n  if (needsSmooshing) {\n    let trees = oldPackages.map(pkg => pkg.v2Tree).reverse();\n    let smoosher = new SmooshPackageJSON(trees, { annotation: originalPackage.name });\n    return broccoliMergeTrees([...trees, smoosher], { overwrite: true });\n  } else {\n    return oldPackages[0].v2Tree;\n  }\n}\n"]}