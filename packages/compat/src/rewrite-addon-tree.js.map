{"version":3,"file":"rewrite-addon-tree.js","sourceRoot":"","sources":["rewrite-addon-tree.ts"],"names":[],"mappings":";;;;;AA4CA,mCA0CC;AAtFD,sEAA0C;AAC1C,gFAA8C;AAC9C,sDAA8B;AAG9B,gEAAsC;AACtC,uCAA2D;AAC3D,+BAAsC;AAqCtC,SAAwB,gBAAgB,CACtC,IAAU,EACV,IAAY,EACZ,UAAkB;IAElB,IAAI,OAAO,GAA+B,EAAE,CAAC;IAE7C,IAAI,GAAG,IAAI,qBAAS,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE;QACtC,KAAK,IAAI,IAAI,IAAI,IAAA,sBAAW,EAAC,UAAU,CAAC,EAAE,CAAC;YACzC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC1B,SAAS;YACX,CAAC;YACD,MAAM,QAAQ,GAAG,IAAA,WAAI,EAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YACxC,IAAI,CAAC,IAAA,mBAAQ,EAAC,QAAQ,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC;gBACjC,SAAS;YACX,CAAC;YACD,IAAA,mBAAQ,EAAC,QAAQ,EAAE,IAAA,WAAI,EAAC,UAAU,EAAE,IAAA,eAAQ,EAAC,IAAI,EAAE,KAAK,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC;QAC1E,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,SAAS,GAAG,IAAI,gBAAM,CACxB,IAAI,EACJ;QACE,YAAY,EAAE,IAAI,MAAM,CAAC,IAAI,UAAU,GAAG,CAAC;QAC3C,aAAa,EAAE,CAAC,QAAkB,EAAE,EAAE;YACpC,KAAK,IAAI,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAC7B,OAAO,CAAC,OAAO,CAAC,GAAG,GAAG,IAAI,IAAI,OAAO,EAAE,CAAC;YAC1C,CAAC;QACH,CAAC;KACF,EACD;QACE,MAAM,EAAE,UAAU;QAClB,UAAU,EAAE,IAAI;KACjB,CACF,CAAC;IACF,IAAI,QAAQ,GAAG,IAAA,yBAAW,EAAC,IAAI,EAAE;QAC/B,OAAO,EAAE,CAAC,GAAG,UAAU,KAAK,CAAC;KAC9B,CAAC,CAAC;IACH,OAAO;QACL,IAAI,EAAE,IAAA,8BAAU,EAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;QACvC,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,iBAAiB,EAAE,OAAO,EAAE,CAAC;KAChD,CAAC;AACJ,CAAC","sourcesContent":["import buildFunnel from 'broccoli-funnel';\nimport mergeTrees from 'broccoli-merge-trees';\nimport Snitch from './snitch';\nimport type { Node } from 'broccoli-node-api';\nimport type { AddonMeta } from '@embroider/core';\nimport AddToTree from './add-to-tree';\nimport { moveSync, readdirSync, statSync } from 'fs-extra';\nimport { join, basename } from 'path';\n\n/*\n  The traditional addon and addon-test-support trees allows you to emit modules\n  under any package you feel like. Which we are NOT COOL WITH.\n\n  This transform re-captures anything you try to put into other people's\n  packages, puts them back into your own, and tracks what renaming is required\n  by your consumers so they can still find those things.\n\n  Example:\n\n  ember-qunit emits an addon-test-support tree like:\n\n  ├── ember-qunit\n  │   ├── adapter.js\n  │   ├── index.js\n  │   └── ...\n  └── qunit\n      └── index.js\n\n  The part that is under \"ember-qunit\" gets handled normally, in that we can\n  merge it directly into our own v2 package root so people can import the\n  modules from their tests.\n\n  But the shim under \"qunit\" gets moved *into* the ember-qunit package, and\n  consumers of ember-qunit will get renaming from:\n\n  import { test } from 'qunit';\n\n  to\n\n  import { test } from 'ember-qunit/qunit';\n*/\n\ntype GetMeta = () => Partial<AddonMeta>;\n\nexport default function rewriteAddonTree(\n  tree: Node,\n  name: string,\n  moduleName: string\n): { tree: Node; getMeta: GetMeta } {\n  let renamed: { [name: string]: string } = {};\n\n  tree = new AddToTree(tree, outputPath => {\n    for (let file of readdirSync(outputPath)) {\n      if (!file.endsWith('.js')) {\n        continue;\n      }\n      const filePath = join(outputPath, file);\n      if (!statSync(filePath).isFile()) {\n        continue;\n      }\n      moveSync(filePath, join(outputPath, basename(file, '.js'), 'index.js'));\n    }\n  });\n\n  let goodParts = new Snitch(\n    tree,\n    {\n      allowedPaths: new RegExp(`^${moduleName}/`),\n      foundBadPaths: (badPaths: string[]) => {\n        for (let badPath of badPaths) {\n          renamed[badPath] = `${name}/${badPath}`;\n        }\n      },\n    },\n    {\n      srcDir: moduleName,\n      allowEmpty: true,\n    }\n  );\n  let badParts = buildFunnel(tree, {\n    exclude: [`${moduleName}/**`],\n  });\n  return {\n    tree: mergeTrees([goodParts, badParts]),\n    getMeta: () => ({ 'renamed-modules': renamed }),\n  };\n}\n"]}